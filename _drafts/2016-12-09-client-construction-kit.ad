---
layout: post
title:  "NTP Client Construction Kit"
date: 2016-12-09 22:46:30
author: ESR
---

One of our major development pushes, now drawing to a close, was to
move as much of the NTP code out of C as was practical to some other
language. The point of this was to banish buffer overruns,
stale-pointer bugs, resource leaks, and all the other ills C is heir
to.  These are huge maintainence drags, and fertile sources of
security problems.

The NTP daemon itself still needs to be in C, or in some compiled
language at least as fast as C, because it's doing some soft-realtime
things and needs to react at machine speed.  But most of the auxiliary
tools don't need to be, because they only need to look fast to humans
rather than other software and machines.  And programs that don't need
to be in C should not be.

Thus, we've moved ntpq, ntpkeygen, and (most recently) ntpdig from C
to Python. The ntpq program is useful for examining and
hot-configuring a running ntpd. The ntpdig program (formerly known as sntp) is a
very simple NTP protocol client sometimes used in situations where
one-shot time syncing suffices and the full weight of ntpd is not
required. The ntpkeygen program is used to generate cryptographic keys for
authenticated NTP connections.

We moved these to Python, rather than some other random scripting
language, because (a) our build engine is implemented in it,
minimizing additional dependencies, (b) I like Python and am
comfortable in it, and (c) it seems a safe choice as a language for
long-term infrastructure, not a fad that will dissipate in three
years.

Doing this move replaced over 10KLOC of C with about 3KLOC of much
cleaner, clearer Python - a good thing in itself. It also presented
another opportunity.  ntpq and ntpdig had been written at different
times by different people. Both are clients for varuations of the NTP
packet protocol, In both, the network-protocol back end was
unhealthily entangled with the application-specific front end.

During the Python rewrite, one of my goals was to factor out that back
end, cleanly separating it from the front-end logic. The NTP protocol
handling and various other re-usable parts became a loadable Python
module. The specific parts of ntpq and ntpdig became much smaller and
lighter, easier to maintain and extend.  In the end, the shared
back-end came out to smidge less than half of that 3KLOC.

And... that back end amounts to being a construction kit for easy and
rapid construction of NTP new protocol clients. I demonstrated this by
requiring only a few hours to write another one.

Two people on the NTPsec team (Gary Miller and myself) have prior
experience with another project, http://www.catb.org/gpsd/[GPSD].  One
of the tools that project ships is called "gpsmon".  It's a diagnostic
tool for examining the output from a running GPS and (for some types)
changing various control and mode settings. It's what's nowadays
called a "TUI" -Terminal User Interface program, meant to run in a
terminal emulator but with a visual full-screen interface.

TUIs are a good interface-design pattern for diagnostic tools that
should run fast and light.  When Gary suggested that we do an
equivalent of gpsmon for NTP, I liked the idea immediately.  I
envisioned a handy, self-updating status display for time-service
admonistrators - something a bit more modern in flavor than the
extremely old-school and rather clunky command-line interface of ntpq,
but without the overhead and complexity of a full GUI.

The Python back end factored out so much work the proof-of-concept
version of ntpmon took me only about 45 minutes to write.  To date it
has consumed probably less than four hours of development time and is
less than 200 lines of code, and yet is a fully production-capable
tool that many time-service adminstrators will likely want to have
running constantly where they can glance at it.

Here's a screen shot:

image::/assets/ntpmon.png[]

Top window is a peer status report, bottom an MRUlist that tells
you where the heavy traffic is hitting your server from.  The status
line tells you how fresh the report is.  The tool samples at half the
shortest poll interval seen in the last peer list.

This is what code reuse gets you when you do it right.  It's also an
excellent demonstration of why not to write in C if you don't have to;
in that language, an ntpmon equivalent would doubtless have taken far
longer to write, and been far more fragile when it was done.

I don't know what kind of NTP protocol client there will be demand for next.
I do know that it's better to have the option of writing them quickly 
and easily than not -- if only because it lowers the cost of experiments
and exploring the design space.

// end

---
layout: post
title:  "Heat it Up"
date:   2017-01-28 00:30:00 -0000
author: GEM
---

In my previous post, I introduced +ntpviz+, a way to quantify and visualize
what ntpd is doing.  The graphs immediately made obvious that some externality
was degrading ntpd accuracy.  Experimentation showed the wild card
was temperature.  This post will show how to measure and graph temperature
and illuminate its affects on NTP performance.

== Measure it ==

Before we can understand temperature effects we must gather temperature
data.  Keane Wolter recently added a program to the contrib/ directory
that greatly simplifies this task. +temp-log+ automatically gathers data
four different types of sources and logs it to a file that can be used
by +ntpviz+.

When the +temp-log+ man page is available it will document the potential
temperature choices.  For now, you just need to know how to run it.  Easy,
root is not required.  The user just needs to be able to write to
your ntpd logs directory.  Usually this is the user ntpuser.  Just run this:

----
export FILE=/var/log/ntpstats/temps
/usr/local/src/NTP/ntpsec/contrib/temp-log.py -l  ${FILE} -w 300 &
----

That will log available temperatures to a file that ntpviz will automatically
use with no further configuration.  Congratulate yourself, check your +ntpviz+
lots tomorrow.

== Unexplained squiggles ==

Now might be a time to re-read the description in my last post of
the temperature here: https://blog.ntpsec.org/2016/12/19/ntpviz-intro.html#so-much-data[So Much Data]

To summarize: CPU load spikes and room temperature seemed to correlate with
aberrations in the system clock.  But without temperature data it might
have been just wishful thinking.  Thus the need to collect temperature data.

This is a New Year, so here is a new plot of time and frequency offsets.  
Taken from a plain Raspberry Pi 3 with a GPS HAT.

image::/assets/24Jan-local-offset.png[]

And a matching plot of Local Frequency Offset and ZONE0 temperature.

image::/assets/24Jan-local-freq-temps.png[]

ZONE0 is the temperature sensor inside most CPU's.  The drop in both
graphs from 08:00Z to 13:00Z is night time when the room heat was off.
The spikes at 23 minutes after the hour, each hour, are largish cron
jobs.

The summary data for those plots:

.Percentiles
[format="csv", options="header"]
|===
 ,Min,1% ,5%, 50%, 95%, 99%, Max
Local Clock Time Offset,-9.463,-1.181,-0.709,-0.050,0.493,4.324,8.128
Local Clock Frequency Offset,-4.366,-4.337,-4.279,-3.606,-2.764,-2.659,-2.482
Temp ZONE0,42.932,42.932,43.470,46.160,49.388,49.388,54.230
|===


.Ranges
[format="csv", options="header"]
|===
 ,90% ,95% ,StdDev ,Mean ,Units
Local Clock Time Offset,1.202,5.505,0.763,,-0.002,µs
Local Clock Frequency Offset,1.515,1.678,0.513,-3.581,ppm
Temp ZONE0,5.918,6.456,2.004,45.992,°C
|===

Basically this Raspberry Pi 3 can hold its Local Time Offset to a Standard
Deviation of about 0.7 µs and its Frequency to about 0.5 ppm.

== zero TC ==

The math of how temperature changes frequency in a crystal is complex.
It depends on many variables.  Some important ones are how the Crystal
was cut, how it is excited, and even how long the crystal has aged.  So
there is no easy way to correct for it in software.

As you can see from the above plots, the crystal speeds up when the
temperature increases.  Achim Gratz recently used a Raspberry Pi to show
that as you heat up the crystal to a temperature T0 that the temperature
affects the the frequency less and less.  As you continue to heat up the
past T0 the temperature dependence returns.

This magic temperature T0 is called the 'zero Temperature Coefficient'
point, abbreviated zero TC.  In Achim's case zero TC is when his CPU
temperature is 60C.  The crystal is on the flip side of the PCB board
so the actual crystal zero TC is not known.

The math and physics of crystals gets complicated.  If you want
to dive into the theory this is a good paper on
 http://www.ieee-uffc.org/frequency-control/learning-vig.asp?chapter=vigstatc[Static Frequency versus Temperature Stability]

This has a simple application to NTP time keeping.  If we can heat up
our NTP server, to the zero TC point, it becomes less influences by
temperature fluctuations and so performs better.

== So What ==

Very interesting you may be thinking, but so what?  You do not have
a laboratory oven and your significant other will likely complain if
you heat up your server room to 60C.

But you only need to heat up the Raspberry Pi, not your room.  Most people
put heat sinks on their CPU's, Achim just put his CPU in a bubble wrap
mailing envelope.  The results are immediately obvious and good.

image::/assets/27Jan-local-offset.png[]

Before 22:00Z the Raspberry Pi was open to room air.  At 22:00 the board
was placed in the envelope.  At about 05:00Z the CPU stabilized at
60C.

As the temperature increased the local time and frequency offsets
stabilized.  The envelope reduced time spike by 30%.  Elevating to 60C
made even more of an improvement.

If you do nothing else today, put your Raspberry Pi in an envelope.

== makeheat ==

Achim's second good idea was to run a simple program on the Raspberry Pi to
hold the CPU to 60C.  I have written a new program +makeheat+ and placed
it in the contrib directory to replicate his program.  You do not even 
need to be root to run it:

----
./makeheat -t 60 &
----

The program will run on the background and try to hold your CPU at 60C.

== Results ==

The results of these two simple changes are clear.  The plot of time and
frequency offsets:

image::/assets/28Jan-local-offset.png[]

Here is the matching plot of Local Frequency Offset and ZONE0 temperature.

image::/assets/28Jan-local-freq-temps.png[]

.Percentiles
[format="csv", options="header"]
|===
 ,Min,1% ,5%, 50%, 95%, 99%, Max
Local Clock Time Offset, -9.088, -0.588, -0.350, -0.011, 0.342, 1.297, 3.888
Local Clock Frequency Offset, -1.192, -1.170, -1.126, -0.985, -0.873, -0.848, -0.750
Temp ZONE0, 59.072, 59.072, 59.072, 59.610, 60.148, 63.376, 63.914
|===

.Ranges
[format="csv", options="header"]
|===
 ,90% ,95% ,StdDev ,Mean ,Units
Local Clock Time Offset, 0.692, 1.885, 0.350, -0.001, µs
Local Clock Frequency Offset, 0.253, 0.322, 0.073, -0.985, ppm
Temp ZONE0, 1.076, 4.304, 0.651, 59.718, °C
|===

The CPU temperature is now held to a Standard Deviation of 0.7 °C, the
local time offset to 0.35 µs and the local frequency offset to 0.073 ppm.

That is an improvement of 2x in time and almost 7x in frequency!  Amazing
what a little bubble wrap can do.

// end
